{"version":3,"file":"static/js/1603.a55de278.chunk.js","mappings":"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","sources":["../node_modules/immer/src/utils/env.ts","../node_modules/immer/src/utils/errors.ts","../node_modules/immer/src/utils/common.ts","../node_modules/immer/src/utils/plugins.ts","../node_modules/immer/src/core/scope.ts","../node_modules/immer/src/core/finalize.ts","../node_modules/immer/src/core/proxy.ts","../node_modules/immer/src/core/immerClass.ts","../node_modules/immer/src/core/current.ts","../node_modules/immer/src/immer.ts"],"sourcesContent":["// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n * Regardless whether they are enumerable or symbols\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tReflect.ownKeys(obj).forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc.writable === false) {\n\t\t\t\tdesc.writable = true\n\t\t\t\tdesc.configurable = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\tvalue: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn Object.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = Object.create(proto)\n\t\treturn Object.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.entries (only string-like, enumerables) instead of each()\n\t\tObject.entries(obj).forEach(([key, value]) => freeze(value, true))\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(value, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path)\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// Immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\t// Per #590, we never freeze symbolic properties. Just to make sure don't accidentally interfere\n\t\t// with other frameworks.\n\t\tif (\n\t\t\t(!parentState || !parentState.scope_.parent_) &&\n\t\t\ttypeof prop !== \"symbol\" &&\n\t\t\tObject.prototype.propertyIsEnumerable.call(targetObject, prop)\n\t\t)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\";\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n"],"names":["NOTHING","Symbol","for","DRAFTABLE","DRAFT_STATE","die","error","Error","concat","getPrototypeOf","Object","isDraft","value","isDraftable","_value$constructor","isPlainObject","Array","isArray","constructor","isMap","isSet","objectCtorString","prototype","toString","proto","Ctor","hasOwnProperty","call","Function","each","obj","iter","getArchtype","Reflect","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","set","propOrOldValue","t","add","target","Map","Set","latest","copy_","base_","shallowCopy","base","strict","slice","isPlain","descriptors","getOwnPropertyDescriptors","keys","i","length","desc","writable","configurable","get","enumerable","create","assign","freeze","deep","arguments","undefined","isFrozen","clear","delete","dontMutateFrozenCollections","entries","_ref","currentScope","plugins","getPlugin","pluginKey","plugin","getCurrentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer2","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","modified_","finalize","maybeFreeze","generateReplacementPatches_","rootScope","path","childValue","finalizeProperty","scope_","finalized_","resultEach","isSet2","generatePatches_","parentState","targetObject","rootPath","targetIsSet","res","assigned_","autoFreeze_","propertyIsEnumerable","objectTraps","source","_desc$get","getDescriptorFromProto","draft_","readPropFromProto","peek","prepareCopy","createProxy","current2","currentState","x","y","markChanged","Number","isNaN","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","setPrototypeOf","arrayTraps","useStrictShallowCopy_","fn","apply","this","parent","proxyMap_","proxySet_","isManual_","traps","revoke","proxy","Proxy","revocable","createProxyProxy","push","currentImpl","copy","immer","config","_this","produce","recipe","defaultBase","self","base2","_len2","args","_key2","hasError","p","ip","produceWithPatches","_len3","_key3","patches","inversePatches","autoFreeze","setAutoFreeze","useStrictShallowCopy","setUseStrictShallowCopy","createDraft","current","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","bind"],"sourceRoot":""}